<?php
/**
 * AlertApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Looker API 4.0 Reference
 *
 * API 4.0 is the current release of the Looker API. API 3.x has been removed.  ### Authorization  The classic method of API authorization uses Looker **API** credentials for authorization and access control. Looker admins can create API credentials on Looker's **Admin/Users** page.  API 4.0 adds additional ways to authenticate API requests, including OAuth and CORS requests.  For details, see [Looker API Authorization](https://cloud.google.com/looker/docs/r/api/authorization).   ### API Explorer  The API Explorer is a Looker-provided utility with many new and unique features for learning and using the Looker API and SDKs.  For details, see the [API Explorer documentation](https://cloud.google.com/looker/docs/r/api/explorer).   ### Looker Language SDKs  The Looker API is a RESTful system that should be usable by any programming language capable of making HTTPS requests. SDKs for a variety of programming languages are also provided to streamline using the API. Looker has an OpenSource [sdk-codegen project](https://github.com/looker-open-source/sdk-codegen) that provides several language SDKs. Language SDKs generated by `sdk-codegen` have an Authentication manager that can automatically authenticate API requests when needed.  For details on available Looker SDKs, see [Looker API Client SDKs](https://cloud.google.com/looker/docs/r/api/client_sdks).   ### API Versioning  Future releases of Looker expand the latest API version release-by-release to securely expose more and more of the core power of the Looker platform to API client applications. API endpoints marked as \"beta\" may receive breaking changes without warning (but we will try to avoid doing that). Stable (non-beta) API endpoints should not receive breaking changes in future releases.  For details, see [Looker API Versioning](https://cloud.google.com/looker/docs/r/api/versioning).   ### In This Release  API 4.0 is the only supported API version for Looker starting with release 23.18. API 3.0 and 3.1 have been removed.  API 4.0 has better support for strongly typed languages like TypeScript, Kotlin, Swift, Go, C#, and more.  See the [API 4.0 GA announcement](https://developers.looker.com/api/advanced-usage/version-4-ga) for more information about API 4.0.  The API Explorer can be used to [interactively compare](https://cloud.google.com/looker/docs/r/api/explorer#comparing_api_versions) the differences between API 3.1 and 4.0.   ### API and SDK Support Policies  Looker API versions and language SDKs have varying support levels. Please read the API and SDK [support policies](https://cloud.google.com/looker/docs/r/api/support-policy) for more information.
 *
 * The version of the OpenAPI document: 4.0.24.10
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Looker;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * AlertApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class AlertApi
{
    protected \GuzzleHttp\ClientInterface $client;

    protected \OpenAPI\Client\Configuration $config;

    protected \OpenAPI\Client\HeaderSelector $headerSelector;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'alertNotifications' => [
            'application/json',
        ],
        'createAlert' => [
            'application/json',
        ],
        'deleteAlert' => [
            'application/json',
        ],
        'enqueueAlert' => [
            'application/json',
        ],
        'followAlert' => [
            'application/json',
        ],
        'getAlert' => [
            'application/json',
        ],
        'readAlertNotification' => [
            'application/json',
        ],
        'searchAlerts' => [
            'application/json',
        ],
        'unfollowAlert' => [
            'application/json',
        ],
        'updateAlert' => [
            'application/json',
        ],
        'updateAlertField' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        protected $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): \OpenAPI\Client\Configuration
    {
        return $this->config;
    }

    /**
     * Operation alertNotifications
     *
     * Alert Notifications
     *
     * @param  int $limit (Optional) Number of results to return (used with &#x60;offset&#x60;). (optional)
     * @param  int $offset (Optional) Number of results to skip before returning any (used with &#x60;limit&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['alertNotifications'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AlertNotifications[]|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error
     */
    public function alertNotifications($limit = null, $offset = null, string $contentType = self::contentTypes['alertNotifications'][0])
    {
        [$response] = $this->alertNotificationsWithHttpInfo($limit, $offset, $contentType);
        return $response;
    }

    /**
     * Operation alertNotificationsWithHttpInfo
     *
     * Alert Notifications
     *
     * @param  int $limit (Optional) Number of results to return (used with &#x60;offset&#x60;). (optional)
     * @param  int $offset (Optional) Number of results to skip before returning any (used with &#x60;limit&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['alertNotifications'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AlertNotifications[]|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function alertNotificationsWithHttpInfo($limit = null, $offset = null, string $contentType = self::contentTypes['alertNotifications'][0])
    {
        $request = $this->alertNotificationsRequest($limit, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AlertNotifications[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AlertNotifications[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AlertNotifications[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AlertNotifications[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AlertNotifications[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation alertNotificationsAsync
     *
     * Alert Notifications
     *
     * @param  int $limit (Optional) Number of results to return (used with &#x60;offset&#x60;). (optional)
     * @param  int $offset (Optional) Number of results to skip before returning any (used with &#x60;limit&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['alertNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function alertNotificationsAsync($limit = null, $offset = null, string $contentType = self::contentTypes['alertNotifications'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        return $this->alertNotificationsAsyncWithHttpInfo($limit, $offset, $contentType)
            ->then(
                fn($response) => $response[0]
            );
    }

    /**
     * Operation alertNotificationsAsyncWithHttpInfo
     *
     * Alert Notifications
     *
     * @param  int $limit (Optional) Number of results to return (used with &#x60;offset&#x60;). (optional)
     * @param  int $offset (Optional) Number of results to skip before returning any (used with &#x60;limit&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['alertNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function alertNotificationsAsyncWithHttpInfo($limit = null, $offset = null, string $contentType = self::contentTypes['alertNotifications'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\AlertNotifications[]';
        $request = $this->alertNotificationsRequest($limit, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType): array {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception): void {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'alertNotifications'
     *
     * @param  int $limit (Optional) Number of results to return (used with &#x60;offset&#x60;). (optional)
     * @param  int $offset (Optional) Number of results to skip before returning any (used with &#x60;limit&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['alertNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function alertNotificationsRequest($limit = null, $offset = null, string $contentType = self::contentTypes['alertNotifications'][0]): \GuzzleHttp\Psr7\Request
    {




        $resourcePath = '/alert_notifications';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAlert
     *
     * Create an alert
     *
     * @param  \OpenAPI\Client\Model\Alert $alert Alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAlert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Alert|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\ValidationError|\OpenAPI\Client\Model\Error
     */
    public function createAlert($alert, string $contentType = self::contentTypes['createAlert'][0])
    {
        [$response] = $this->createAlertWithHttpInfo($alert, $contentType);
        return $response;
    }

    /**
     * Operation createAlertWithHttpInfo
     *
     * Create an alert
     *
     * @param  \OpenAPI\Client\Model\Alert $alert Alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAlert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Alert|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\ValidationError|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAlertWithHttpInfo($alert, string $contentType = self::contentTypes['createAlert'][0])
    {
        $request = $this->createAlertRequest($alert, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (\OpenAPI\Client\Model\Alert::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Alert::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Alert::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if (\OpenAPI\Client\Model\ValidationError::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\ValidationError::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\ValidationError::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = \OpenAPI\Client\Model\Alert::class;
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Alert::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\ValidationError::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAlertAsync
     *
     * Create an alert
     *
     * @param  \OpenAPI\Client\Model\Alert $alert Alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAlertAsync($alert, string $contentType = self::contentTypes['createAlert'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        return $this->createAlertAsyncWithHttpInfo($alert, $contentType)
            ->then(
                fn($response) => $response[0]
            );
    }

    /**
     * Operation createAlertAsyncWithHttpInfo
     *
     * Create an alert
     *
     * @param  \OpenAPI\Client\Model\Alert $alert Alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAlertAsyncWithHttpInfo($alert, string $contentType = self::contentTypes['createAlert'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        $returnType = \OpenAPI\Client\Model\Alert::class;
        $request = $this->createAlertRequest($alert, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType): array {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception): void {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAlert'
     *
     * @param  \OpenAPI\Client\Model\Alert $alert Alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAlertRequest($alert, string $contentType = self::contentTypes['createAlert'][0]): \GuzzleHttp\Psr7\Request
    {

        // verify the required parameter 'alert' is set
        if ($alert === null || (is_array($alert) && count($alert) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alert when calling createAlert'
            );
        }


        $resourcePath = '/alerts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($alert)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($alert));
            } else {
                $httpBody = $alert;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAlert
     *
     * Delete an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAlert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAlert($alert_id, string $contentType = self::contentTypes['deleteAlert'][0]): void
    {
        $this->deleteAlertWithHttpInfo($alert_id, $contentType);
    }

    /**
     * Operation deleteAlertWithHttpInfo
     *
     * Delete an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAlert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAlertWithHttpInfo($alert_id, string $contentType = self::contentTypes['deleteAlert'][0]): array
    {
        $request = $this->deleteAlertRequest($alert_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAlertAsync
     *
     * Delete an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAlertAsync($alert_id, string $contentType = self::contentTypes['deleteAlert'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        return $this->deleteAlertAsyncWithHttpInfo($alert_id, $contentType)
            ->then(
                fn($response) => $response[0]
            );
    }

    /**
     * Operation deleteAlertAsyncWithHttpInfo
     *
     * Delete an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAlertAsyncWithHttpInfo($alert_id, string $contentType = self::contentTypes['deleteAlert'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteAlertRequest($alert_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                fn($response): array => [null, $response->getStatusCode(), $response->getHeaders()],
                function ($exception): void {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAlert'
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAlertRequest($alert_id, string $contentType = self::contentTypes['deleteAlert'][0]): \GuzzleHttp\Psr7\Request
    {

        // verify the required parameter 'alert_id' is set
        if ($alert_id === null || (is_array($alert_id) && count($alert_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alert_id when calling deleteAlert'
            );
        }


        $resourcePath = '/alerts/{alert_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($alert_id !== null) {
            $resourcePath = str_replace(
                '{' . 'alert_id' . '}',
                ObjectSerializer::toPathValue($alert_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enqueueAlert
     *
     * Enqueue an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  bool $force Whether to enqueue an alert again if its already running. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enqueueAlert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enqueueAlert($alert_id, $force = null, string $contentType = self::contentTypes['enqueueAlert'][0]): void
    {
        $this->enqueueAlertWithHttpInfo($alert_id, $force, $contentType);
    }

    /**
     * Operation enqueueAlertWithHttpInfo
     *
     * Enqueue an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  bool $force Whether to enqueue an alert again if its already running. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enqueueAlert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enqueueAlertWithHttpInfo($alert_id, $force = null, string $contentType = self::contentTypes['enqueueAlert'][0]): array
    {
        $request = $this->enqueueAlertRequest($alert_id, $force, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enqueueAlertAsync
     *
     * Enqueue an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  bool $force Whether to enqueue an alert again if its already running. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enqueueAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enqueueAlertAsync($alert_id, $force = null, string $contentType = self::contentTypes['enqueueAlert'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        return $this->enqueueAlertAsyncWithHttpInfo($alert_id, $force, $contentType)
            ->then(
                fn($response) => $response[0]
            );
    }

    /**
     * Operation enqueueAlertAsyncWithHttpInfo
     *
     * Enqueue an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  bool $force Whether to enqueue an alert again if its already running. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enqueueAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enqueueAlertAsyncWithHttpInfo($alert_id, $force = null, string $contentType = self::contentTypes['enqueueAlert'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        $returnType = '';
        $request = $this->enqueueAlertRequest($alert_id, $force, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                fn($response): array => [null, $response->getStatusCode(), $response->getHeaders()],
                function ($exception): void {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enqueueAlert'
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  bool $force Whether to enqueue an alert again if its already running. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enqueueAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enqueueAlertRequest($alert_id, $force = null, string $contentType = self::contentTypes['enqueueAlert'][0]): \GuzzleHttp\Psr7\Request
    {

        // verify the required parameter 'alert_id' is set
        if ($alert_id === null || (is_array($alert_id) && count($alert_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alert_id when calling enqueueAlert'
            );
        }



        $resourcePath = '/alerts/{alert_id}/enqueue';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $force,
            'force', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($alert_id !== null) {
            $resourcePath = str_replace(
                '{' . 'alert_id' . '}',
                ObjectSerializer::toPathValue($alert_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation followAlert
     *
     * Follow an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['followAlert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function followAlert($alert_id, string $contentType = self::contentTypes['followAlert'][0]): void
    {
        $this->followAlertWithHttpInfo($alert_id, $contentType);
    }

    /**
     * Operation followAlertWithHttpInfo
     *
     * Follow an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['followAlert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function followAlertWithHttpInfo($alert_id, string $contentType = self::contentTypes['followAlert'][0]): array
    {
        $request = $this->followAlertRequest($alert_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation followAlertAsync
     *
     * Follow an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['followAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function followAlertAsync($alert_id, string $contentType = self::contentTypes['followAlert'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        return $this->followAlertAsyncWithHttpInfo($alert_id, $contentType)
            ->then(
                fn($response) => $response[0]
            );
    }

    /**
     * Operation followAlertAsyncWithHttpInfo
     *
     * Follow an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['followAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function followAlertAsyncWithHttpInfo($alert_id, string $contentType = self::contentTypes['followAlert'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        $returnType = '';
        $request = $this->followAlertRequest($alert_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                fn($response): array => [null, $response->getStatusCode(), $response->getHeaders()],
                function ($exception): void {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'followAlert'
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['followAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function followAlertRequest($alert_id, string $contentType = self::contentTypes['followAlert'][0]): \GuzzleHttp\Psr7\Request
    {

        // verify the required parameter 'alert_id' is set
        if ($alert_id === null || (is_array($alert_id) && count($alert_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alert_id when calling followAlert'
            );
        }


        $resourcePath = '/alerts/{alert_id}/follow';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($alert_id !== null) {
            $resourcePath = str_replace(
                '{' . 'alert_id' . '}',
                ObjectSerializer::toPathValue($alert_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAlert
     *
     * Get an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAlert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Alert|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error
     */
    public function getAlert($alert_id, string $contentType = self::contentTypes['getAlert'][0])
    {
        [$response] = $this->getAlertWithHttpInfo($alert_id, $contentType);
        return $response;
    }

    /**
     * Operation getAlertWithHttpInfo
     *
     * Get an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAlert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Alert|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAlertWithHttpInfo($alert_id, string $contentType = self::contentTypes['getAlert'][0])
    {
        $request = $this->getAlertRequest($alert_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (\OpenAPI\Client\Model\Alert::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Alert::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Alert::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = \OpenAPI\Client\Model\Alert::class;
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Alert::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAlertAsync
     *
     * Get an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAlertAsync($alert_id, string $contentType = self::contentTypes['getAlert'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        return $this->getAlertAsyncWithHttpInfo($alert_id, $contentType)
            ->then(
                fn($response) => $response[0]
            );
    }

    /**
     * Operation getAlertAsyncWithHttpInfo
     *
     * Get an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAlertAsyncWithHttpInfo($alert_id, string $contentType = self::contentTypes['getAlert'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        $returnType = \OpenAPI\Client\Model\Alert::class;
        $request = $this->getAlertRequest($alert_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType): array {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception): void {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAlert'
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAlertRequest($alert_id, string $contentType = self::contentTypes['getAlert'][0]): \GuzzleHttp\Psr7\Request
    {

        // verify the required parameter 'alert_id' is set
        if ($alert_id === null || (is_array($alert_id) && count($alert_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alert_id when calling getAlert'
            );
        }


        $resourcePath = '/alerts/{alert_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($alert_id !== null) {
            $resourcePath = str_replace(
                '{' . 'alert_id' . '}',
                ObjectSerializer::toPathValue($alert_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readAlertNotification
     *
     * Read a Notification
     *
     * @param  string $alert_notification_id ID of a notification (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readAlertNotification'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AlertNotifications|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\ValidationError|\OpenAPI\Client\Model\Error
     */
    public function readAlertNotification($alert_notification_id, string $contentType = self::contentTypes['readAlertNotification'][0])
    {
        [$response] = $this->readAlertNotificationWithHttpInfo($alert_notification_id, $contentType);
        return $response;
    }

    /**
     * Operation readAlertNotificationWithHttpInfo
     *
     * Read a Notification
     *
     * @param  string $alert_notification_id ID of a notification (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readAlertNotification'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AlertNotifications|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\ValidationError|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function readAlertNotificationWithHttpInfo($alert_notification_id, string $contentType = self::contentTypes['readAlertNotification'][0])
    {
        $request = $this->readAlertNotificationRequest($alert_notification_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (\OpenAPI\Client\Model\AlertNotifications::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\AlertNotifications::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\AlertNotifications::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if (\OpenAPI\Client\Model\ValidationError::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\ValidationError::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\ValidationError::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = \OpenAPI\Client\Model\AlertNotifications::class;
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\AlertNotifications::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\ValidationError::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readAlertNotificationAsync
     *
     * Read a Notification
     *
     * @param  string $alert_notification_id ID of a notification (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readAlertNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readAlertNotificationAsync($alert_notification_id, string $contentType = self::contentTypes['readAlertNotification'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        return $this->readAlertNotificationAsyncWithHttpInfo($alert_notification_id, $contentType)
            ->then(
                fn($response) => $response[0]
            );
    }

    /**
     * Operation readAlertNotificationAsyncWithHttpInfo
     *
     * Read a Notification
     *
     * @param  string $alert_notification_id ID of a notification (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readAlertNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readAlertNotificationAsyncWithHttpInfo($alert_notification_id, string $contentType = self::contentTypes['readAlertNotification'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        $returnType = \OpenAPI\Client\Model\AlertNotifications::class;
        $request = $this->readAlertNotificationRequest($alert_notification_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType): array {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception): void {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readAlertNotification'
     *
     * @param  string $alert_notification_id ID of a notification (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readAlertNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readAlertNotificationRequest($alert_notification_id, string $contentType = self::contentTypes['readAlertNotification'][0]): \GuzzleHttp\Psr7\Request
    {

        // verify the required parameter 'alert_notification_id' is set
        if ($alert_notification_id === null || (is_array($alert_notification_id) && count($alert_notification_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alert_notification_id when calling readAlertNotification'
            );
        }


        $resourcePath = '/alert_notifications/{alert_notification_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($alert_notification_id !== null) {
            $resourcePath = str_replace(
                '{' . 'alert_notification_id' . '}',
                ObjectSerializer::toPathValue($alert_notification_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchAlerts
     *
     * Search Alerts
     *
     * @param  int $limit (Optional) Number of results to return (used with &#x60;offset&#x60;). (optional)
     * @param  int $offset (Optional) Number of results to skip before returning any (used with &#x60;limit&#x60;). (optional)
     * @param  string $group_by (Optional) Dimension by which to order the results(&#x60;dashboard&#x60; | &#x60;owner&#x60;) (optional)
     * @param  string $fields (Optional) Requested fields. (optional)
     * @param  bool $disabled (Optional) Filter on returning only enabled or disabled alerts. (optional)
     * @param  string $frequency (Optional) Filter on alert frequency, such as: monthly, weekly, daily, hourly, minutes (optional)
     * @param  bool $condition_met (Optional) Filter on whether the alert has met its condition when it last executed (optional)
     * @param  string $last_run_start (Optional) Filter on the start range of the last time the alerts were run. Example: 2021-01-01T01:01:01-08:00. (optional)
     * @param  string $last_run_end (Optional) Filter on the start range of the last time the alerts were run. Example: 2021-01-01T01:01:01-08:00. (optional)
     * @param  bool $all_owners (Admin only) (Optional) Filter for all owners. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAlerts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Alert[]|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error
     */
    public function searchAlerts($limit = null, $offset = null, $group_by = null, $fields = null, $disabled = null, $frequency = null, $condition_met = null, $last_run_start = null, $last_run_end = null, $all_owners = null, string $contentType = self::contentTypes['searchAlerts'][0])
    {
        [$response] = $this->searchAlertsWithHttpInfo($limit, $offset, $group_by, $fields, $disabled, $frequency, $condition_met, $last_run_start, $last_run_end, $all_owners, $contentType);
        return $response;
    }

    /**
     * Operation searchAlertsWithHttpInfo
     *
     * Search Alerts
     *
     * @param  int $limit (Optional) Number of results to return (used with &#x60;offset&#x60;). (optional)
     * @param  int $offset (Optional) Number of results to skip before returning any (used with &#x60;limit&#x60;). (optional)
     * @param  string $group_by (Optional) Dimension by which to order the results(&#x60;dashboard&#x60; | &#x60;owner&#x60;) (optional)
     * @param  string $fields (Optional) Requested fields. (optional)
     * @param  bool $disabled (Optional) Filter on returning only enabled or disabled alerts. (optional)
     * @param  string $frequency (Optional) Filter on alert frequency, such as: monthly, weekly, daily, hourly, minutes (optional)
     * @param  bool $condition_met (Optional) Filter on whether the alert has met its condition when it last executed (optional)
     * @param  string $last_run_start (Optional) Filter on the start range of the last time the alerts were run. Example: 2021-01-01T01:01:01-08:00. (optional)
     * @param  string $last_run_end (Optional) Filter on the start range of the last time the alerts were run. Example: 2021-01-01T01:01:01-08:00. (optional)
     * @param  bool $all_owners (Admin only) (Optional) Filter for all owners. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAlerts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Alert[]|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchAlertsWithHttpInfo($limit = null, $offset = null, $group_by = null, $fields = null, $disabled = null, $frequency = null, $condition_met = null, $last_run_start = null, $last_run_end = null, $all_owners = null, string $contentType = self::contentTypes['searchAlerts'][0])
    {
        $request = $this->searchAlertsRequest($limit, $offset, $group_by, $fields, $disabled, $frequency, $condition_met, $last_run_start, $last_run_end, $all_owners, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Alert[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Alert[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Alert[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Alert[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Alert[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchAlertsAsync
     *
     * Search Alerts
     *
     * @param  int $limit (Optional) Number of results to return (used with &#x60;offset&#x60;). (optional)
     * @param  int $offset (Optional) Number of results to skip before returning any (used with &#x60;limit&#x60;). (optional)
     * @param  string $group_by (Optional) Dimension by which to order the results(&#x60;dashboard&#x60; | &#x60;owner&#x60;) (optional)
     * @param  string $fields (Optional) Requested fields. (optional)
     * @param  bool $disabled (Optional) Filter on returning only enabled or disabled alerts. (optional)
     * @param  string $frequency (Optional) Filter on alert frequency, such as: monthly, weekly, daily, hourly, minutes (optional)
     * @param  bool $condition_met (Optional) Filter on whether the alert has met its condition when it last executed (optional)
     * @param  string $last_run_start (Optional) Filter on the start range of the last time the alerts were run. Example: 2021-01-01T01:01:01-08:00. (optional)
     * @param  string $last_run_end (Optional) Filter on the start range of the last time the alerts were run. Example: 2021-01-01T01:01:01-08:00. (optional)
     * @param  bool $all_owners (Admin only) (Optional) Filter for all owners. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAlertsAsync($limit = null, $offset = null, $group_by = null, $fields = null, $disabled = null, $frequency = null, $condition_met = null, $last_run_start = null, $last_run_end = null, $all_owners = null, string $contentType = self::contentTypes['searchAlerts'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        return $this->searchAlertsAsyncWithHttpInfo($limit, $offset, $group_by, $fields, $disabled, $frequency, $condition_met, $last_run_start, $last_run_end, $all_owners, $contentType)
            ->then(
                fn($response) => $response[0]
            );
    }

    /**
     * Operation searchAlertsAsyncWithHttpInfo
     *
     * Search Alerts
     *
     * @param  int $limit (Optional) Number of results to return (used with &#x60;offset&#x60;). (optional)
     * @param  int $offset (Optional) Number of results to skip before returning any (used with &#x60;limit&#x60;). (optional)
     * @param  string $group_by (Optional) Dimension by which to order the results(&#x60;dashboard&#x60; | &#x60;owner&#x60;) (optional)
     * @param  string $fields (Optional) Requested fields. (optional)
     * @param  bool $disabled (Optional) Filter on returning only enabled or disabled alerts. (optional)
     * @param  string $frequency (Optional) Filter on alert frequency, such as: monthly, weekly, daily, hourly, minutes (optional)
     * @param  bool $condition_met (Optional) Filter on whether the alert has met its condition when it last executed (optional)
     * @param  string $last_run_start (Optional) Filter on the start range of the last time the alerts were run. Example: 2021-01-01T01:01:01-08:00. (optional)
     * @param  string $last_run_end (Optional) Filter on the start range of the last time the alerts were run. Example: 2021-01-01T01:01:01-08:00. (optional)
     * @param  bool $all_owners (Admin only) (Optional) Filter for all owners. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAlertsAsyncWithHttpInfo($limit = null, $offset = null, $group_by = null, $fields = null, $disabled = null, $frequency = null, $condition_met = null, $last_run_start = null, $last_run_end = null, $all_owners = null, string $contentType = self::contentTypes['searchAlerts'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\Alert[]';
        $request = $this->searchAlertsRequest($limit, $offset, $group_by, $fields, $disabled, $frequency, $condition_met, $last_run_start, $last_run_end, $all_owners, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType): array {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception): void {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchAlerts'
     *
     * @param  int $limit (Optional) Number of results to return (used with &#x60;offset&#x60;). (optional)
     * @param  int $offset (Optional) Number of results to skip before returning any (used with &#x60;limit&#x60;). (optional)
     * @param  string $group_by (Optional) Dimension by which to order the results(&#x60;dashboard&#x60; | &#x60;owner&#x60;) (optional)
     * @param  string $fields (Optional) Requested fields. (optional)
     * @param  bool $disabled (Optional) Filter on returning only enabled or disabled alerts. (optional)
     * @param  string $frequency (Optional) Filter on alert frequency, such as: monthly, weekly, daily, hourly, minutes (optional)
     * @param  bool $condition_met (Optional) Filter on whether the alert has met its condition when it last executed (optional)
     * @param  string $last_run_start (Optional) Filter on the start range of the last time the alerts were run. Example: 2021-01-01T01:01:01-08:00. (optional)
     * @param  string $last_run_end (Optional) Filter on the start range of the last time the alerts were run. Example: 2021-01-01T01:01:01-08:00. (optional)
     * @param  bool $all_owners (Admin only) (Optional) Filter for all owners. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchAlertsRequest($limit = null, $offset = null, $group_by = null, $fields = null, $disabled = null, $frequency = null, $condition_met = null, $last_run_start = null, $last_run_end = null, $all_owners = null, string $contentType = self::contentTypes['searchAlerts'][0]): \GuzzleHttp\Psr7\Request
    {












        $resourcePath = '/alerts/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_by,
            'group_by', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $disabled,
            'disabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $frequency,
            'frequency', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $condition_met,
            'condition_met', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_run_start,
            'last_run_start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_run_end,
            'last_run_end', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $all_owners,
            'all_owners', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unfollowAlert
     *
     * Unfollow an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unfollowAlert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function unfollowAlert($alert_id, string $contentType = self::contentTypes['unfollowAlert'][0]): void
    {
        $this->unfollowAlertWithHttpInfo($alert_id, $contentType);
    }

    /**
     * Operation unfollowAlertWithHttpInfo
     *
     * Unfollow an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unfollowAlert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unfollowAlertWithHttpInfo($alert_id, string $contentType = self::contentTypes['unfollowAlert'][0]): array
    {
        $request = $this->unfollowAlertRequest($alert_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation unfollowAlertAsync
     *
     * Unfollow an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unfollowAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unfollowAlertAsync($alert_id, string $contentType = self::contentTypes['unfollowAlert'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        return $this->unfollowAlertAsyncWithHttpInfo($alert_id, $contentType)
            ->then(
                fn($response) => $response[0]
            );
    }

    /**
     * Operation unfollowAlertAsyncWithHttpInfo
     *
     * Unfollow an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unfollowAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unfollowAlertAsyncWithHttpInfo($alert_id, string $contentType = self::contentTypes['unfollowAlert'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        $returnType = '';
        $request = $this->unfollowAlertRequest($alert_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                fn($response): array => [null, $response->getStatusCode(), $response->getHeaders()],
                function ($exception): void {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unfollowAlert'
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unfollowAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unfollowAlertRequest($alert_id, string $contentType = self::contentTypes['unfollowAlert'][0]): \GuzzleHttp\Psr7\Request
    {

        // verify the required parameter 'alert_id' is set
        if ($alert_id === null || (is_array($alert_id) && count($alert_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alert_id when calling unfollowAlert'
            );
        }


        $resourcePath = '/alerts/{alert_id}/follow';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($alert_id !== null) {
            $resourcePath = str_replace(
                '{' . 'alert_id' . '}',
                ObjectSerializer::toPathValue($alert_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAlert
     *
     * Update an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  \OpenAPI\Client\Model\Alert $alert Alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAlert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Alert|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\ValidationError|\OpenAPI\Client\Model\Error
     */
    public function updateAlert($alert_id, $alert, string $contentType = self::contentTypes['updateAlert'][0])
    {
        [$response] = $this->updateAlertWithHttpInfo($alert_id, $alert, $contentType);
        return $response;
    }

    /**
     * Operation updateAlertWithHttpInfo
     *
     * Update an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  \OpenAPI\Client\Model\Alert $alert Alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAlert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Alert|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\ValidationError|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAlertWithHttpInfo($alert_id, $alert, string $contentType = self::contentTypes['updateAlert'][0])
    {
        $request = $this->updateAlertRequest($alert_id, $alert, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (\OpenAPI\Client\Model\Alert::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Alert::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Alert::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if (\OpenAPI\Client\Model\ValidationError::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\ValidationError::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\ValidationError::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = \OpenAPI\Client\Model\Alert::class;
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Alert::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\ValidationError::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAlertAsync
     *
     * Update an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  \OpenAPI\Client\Model\Alert $alert Alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAlertAsync($alert_id, $alert, string $contentType = self::contentTypes['updateAlert'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        return $this->updateAlertAsyncWithHttpInfo($alert_id, $alert, $contentType)
            ->then(
                fn($response) => $response[0]
            );
    }

    /**
     * Operation updateAlertAsyncWithHttpInfo
     *
     * Update an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  \OpenAPI\Client\Model\Alert $alert Alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAlertAsyncWithHttpInfo($alert_id, $alert, string $contentType = self::contentTypes['updateAlert'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        $returnType = \OpenAPI\Client\Model\Alert::class;
        $request = $this->updateAlertRequest($alert_id, $alert, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType): array {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception): void {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAlert'
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  \OpenAPI\Client\Model\Alert $alert Alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAlertRequest($alert_id, $alert, string $contentType = self::contentTypes['updateAlert'][0]): \GuzzleHttp\Psr7\Request
    {

        // verify the required parameter 'alert_id' is set
        if ($alert_id === null || (is_array($alert_id) && count($alert_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alert_id when calling updateAlert'
            );
        }

        // verify the required parameter 'alert' is set
        if ($alert === null || (is_array($alert) && count($alert) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alert when calling updateAlert'
            );
        }


        $resourcePath = '/alerts/{alert_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($alert_id !== null) {
            $resourcePath = str_replace(
                '{' . 'alert_id' . '}',
                ObjectSerializer::toPathValue($alert_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($alert)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($alert));
            } else {
                $httpBody = $alert;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAlertField
     *
     * Update select fields on an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  \OpenAPI\Client\Model\AlertPatch $alert_patch Alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAlertField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Alert|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\ValidationError|\OpenAPI\Client\Model\Error
     */
    public function updateAlertField($alert_id, $alert_patch, string $contentType = self::contentTypes['updateAlertField'][0])
    {
        [$response] = $this->updateAlertFieldWithHttpInfo($alert_id, $alert_patch, $contentType);
        return $response;
    }

    /**
     * Operation updateAlertFieldWithHttpInfo
     *
     * Update select fields on an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  \OpenAPI\Client\Model\AlertPatch $alert_patch Alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAlertField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Alert|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\ValidationError|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAlertFieldWithHttpInfo($alert_id, $alert_patch, string $contentType = self::contentTypes['updateAlertField'][0])
    {
        $request = $this->updateAlertFieldRequest($alert_id, $alert_patch, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (\OpenAPI\Client\Model\Alert::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Alert::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Alert::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if (\OpenAPI\Client\Model\ValidationError::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\ValidationError::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\ValidationError::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if (\OpenAPI\Client\Model\Error::class === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (\OpenAPI\Client\Model\Error::class !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, \OpenAPI\Client\Model\Error::class, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = \OpenAPI\Client\Model\Alert::class;
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Alert::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\ValidationError::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        \OpenAPI\Client\Model\Error::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAlertFieldAsync
     *
     * Update select fields on an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  \OpenAPI\Client\Model\AlertPatch $alert_patch Alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAlertField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAlertFieldAsync($alert_id, $alert_patch, string $contentType = self::contentTypes['updateAlertField'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        return $this->updateAlertFieldAsyncWithHttpInfo($alert_id, $alert_patch, $contentType)
            ->then(
                fn($response) => $response[0]
            );
    }

    /**
     * Operation updateAlertFieldAsyncWithHttpInfo
     *
     * Update select fields on an alert
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  \OpenAPI\Client\Model\AlertPatch $alert_patch Alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAlertField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAlertFieldAsyncWithHttpInfo($alert_id, $alert_patch, string $contentType = self::contentTypes['updateAlertField'][0]): \GuzzleHttp\Promise\PromiseInterface
    {
        $returnType = \OpenAPI\Client\Model\Alert::class;
        $request = $this->updateAlertFieldRequest($alert_id, $alert_patch, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType): array {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception): void {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAlertField'
     *
     * @param  string $alert_id ID of an alert (required)
     * @param  \OpenAPI\Client\Model\AlertPatch $alert_patch Alert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAlertField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAlertFieldRequest($alert_id, $alert_patch, string $contentType = self::contentTypes['updateAlertField'][0]): \GuzzleHttp\Psr7\Request
    {

        // verify the required parameter 'alert_id' is set
        if ($alert_id === null || (is_array($alert_id) && count($alert_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alert_id when calling updateAlertField'
            );
        }

        // verify the required parameter 'alert_patch' is set
        if ($alert_patch === null || (is_array($alert_patch) && count($alert_patch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alert_patch when calling updateAlertField'
            );
        }


        $resourcePath = '/alerts/{alert_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($alert_id !== null) {
            $resourcePath = str_replace(
                '{' . 'alert_id' . '}',
                ObjectSerializer::toPathValue($alert_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($alert_patch)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($alert_patch));
            } else {
                $httpBody = $alert_patch;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
